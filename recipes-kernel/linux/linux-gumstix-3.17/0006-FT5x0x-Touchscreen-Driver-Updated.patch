From 7d47953cb8160824148d90ef3e6e0c5053072591 Mon Sep 17 00:00:00 2001
From: Adam YH Lee <adam.yh.lee@gmail.com>
Date: Mon, 15 Dec 2014 18:34:18 -0800
Subject: [PATCH 3/4] FT5x0x Touchscreen Driver Updated

The original driver written for the Kernel version 3.5 is outdated
on 3.17 in regards to these two respects.

The original code:

1. uses Linux kernel API that need to be updated. For example,
'input_mt_init_slots' take extra parameter. Also 'devm_gpio_request_one'
is considered more modern over 'gpio_request_one'.

2. has incomplete Device Tree support. Device is not registered in
the open firmware table (of_match_table).

Also some refactoring is done. Macro 'module_i2c_driver' is used
to write init and exit functions.

The driver has been tested with mtview, evtest on both device tree
and platform data (by using pdata_quirks) driven Kernel 3.17.

It assumes that there is no reset pin associated to a GPIO. This
may not be true on other implementations of FT5x0x.

Much of these changes are based on the edt-ft5x06 driver. However,
the EDT specific driver is not compatible with this at firmware level.

Additional work to be done from here on includes the followings:

1. Although not observed, I am not sure all resources are freed when
at rmmod. When/how do we use free_irq, gpio_free, input_free_device
or kfree calls?

2. PM (suspend / resume) is not tested.
---
 arch/arm/mach-omap2/pdata-quirks.c    |  40 ++++++
 drivers/input/touchscreen/ft5x06_ts.c | 253 +++++++++++++---------------------
 2 files changed, 137 insertions(+), 156 deletions(-)

diff --git a/arch/arm/mach-omap2/pdata-quirks.c b/arch/arm/mach-omap2/pdata-quirks.c
index 90c88d4..9856da7 100644
--- a/arch/arm/mach-omap2/pdata-quirks.c
+++ b/arch/arm/mach-omap2/pdata-quirks.c
@@ -7,6 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+
 #include <linux/clk.h>
 #include <linux/davinci_emac.h>
 #include <linux/gpio.h>
@@ -14,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/of_platform.h>
 #include <linux/wl12xx.h>
+#include <linux/input/ft5x06_ts.h>
 
 #include <linux/platform_data/pinctrl-single.h>
 #include <linux/platform_data/iommu-omap.h>
@@ -63,6 +65,38 @@ static inline void legacy_init_wl12xx(unsigned ref_clock,
 }
 #endif
 
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_NEWHAVEN_FT5X0X)
+/* Capacitive Touchscreen */
+static struct ft5x0x_platform_data overo_captouch_info = {
+       .irq_gpio       = 10,
+       .wake_gpio      = 31,
+};
+
+static struct i2c_board_info overo_i2c2_boardinfo[] = {
+        {
+                I2C_BOARD_INFO("ft5x0x_ts", 0x38),
+                .platform_data  = &overo_captouch_info,
+        },
+};
+
+static void __init __used legacy_init_ft5x0x(unsigned int irq_gpio,
+                                             unsigned int wake_gpio)
+{
+    int ret;
+
+    overo_i2c2_boardinfo[0].irq = gpio_to_irq(10);
+    ret = omap_register_i2c_bus(3, 100, overo_i2c2_boardinfo, ARRAY_SIZE(overo_i2c2_boardinfo));
+
+    pr_info("FT5X0X configured\n");
+}
+#else
+static void __init __used legacy_init_ft5x0x(unsigned int irq_gpio,
+                                             unsigned int wake_gpio)
+{
+    pr_err("FT5X0X not configured\n");
+}
+#endif
+
 #ifdef CONFIG_MACH_NOKIA_N8X0
 static void __init omap2420_n8x0_legacy_init(void)
 {
@@ -73,6 +107,11 @@ static void __init omap2420_n8x0_legacy_init(void)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP3
+static void __init gumstix_arbor43c_legacy_init(void)
+{
+    legacy_init_ft5x0x(10, 31);
+}
+
 static void __init hsmmc2_internal_input_clk(void)
 {
 	u32 reg;
@@ -377,6 +416,7 @@ static struct pdata_init pdata_quirks[] __initdata = {
 	{ "ti,omap3-evm-37xx", omap3_evm_legacy_init, },
 	{ "ti,omap3-zoom3", omap3_zoom_legacy_init, },
 	{ "ti,am3517-evm", am3517_evm_legacy_init, },
+	{ "gumstix,omap3-overo-arbor43c", gumstix_arbor43c_legacy_init, },
 #endif
 #ifdef CONFIG_ARCH_OMAP4
 	{ "ti,omap4-sdp", omap4_sdp_legacy_init, },
diff --git a/drivers/input/touchscreen/ft5x06_ts.c b/drivers/input/touchscreen/ft5x06_ts.c
index e863ab7..b558001 100644
--- a/drivers/input/touchscreen/ft5x06_ts.c
+++ b/drivers/input/touchscreen/ft5x06_ts.c
@@ -17,12 +17,11 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-/* 
+/*
  * This is a driver for the FocalTech FT5x0x family of touch controllers
  * use in Newhaven capacitive touchscreens.  Note: this does not support with
  * EDT "Polytouch" controllers.
  */
-#define DEBUG
 
 #include <linux/module.h>
 #include <linux/interrupt.h>
@@ -42,9 +41,9 @@ struct ft5x0x_ts_data {
 	struct input_dev *input;
 	struct delayed_work work;
 
-    int reset_gpio;
-    int irq_gpio;
-    int wake_gpio;
+	int reset_gpio;
+	int irq_gpio;
+	int wake_gpio;
 };
 
 static int ft5x0x_ts_readwrite(struct i2c_client *client, u16 wr_len, u8 *wr_buf, u16 rd_len, u8 *rd_buf)
@@ -52,6 +51,7 @@ static int ft5x0x_ts_readwrite(struct i2c_client *client, u16 wr_len, u8 *wr_buf
 	struct i2c_msg wrmsg[2];
 	int i = 0;
 	int ret;
+
 	if (wr_len) {
 		wrmsg[i].addr = client->addr;
 		wrmsg[i].flags = 0;
@@ -67,12 +67,16 @@ static int ft5x0x_ts_readwrite(struct i2c_client *client, u16 wr_len, u8 *wr_buf
 		wrmsg[i].buf = rd_buf;
 		i++;
 	}
-	
+
 	ret = i2c_transfer(client->adapter, wrmsg, i);
-	if (ret < 0)
+
+	if (ret < 0) {
 		return ret;
-	if (ret != i)
+	}
+
+	if (ret != i) {
 		return -EIO;
+	}
 
 	return 0;
 }
@@ -80,10 +84,10 @@ static int ft5x0x_ts_readwrite(struct i2c_client *client, u16 wr_len, u8 *wr_buf
 static int ft5x0x_register_write(struct ft5x0x_ts_data *tsdata, u8 addr, u8 value)
 {
 	u8 wrbuf[2];
-        wrbuf[0] = addr;
-        wrbuf[1] = value;
+	wrbuf[0] = addr;
+	wrbuf[1] = value;
 
-        return ft5x0x_ts_readwrite(tsdata->client, 2, wrbuf, 0, NULL);
+	return ft5x0x_ts_readwrite(tsdata->client, 2, wrbuf, 0, NULL);
 }
 
 static int ft5x0x_register_read(struct ft5x0x_ts_data *tsdata, u8 addr)
@@ -91,12 +95,14 @@ static int ft5x0x_register_read(struct ft5x0x_ts_data *tsdata, u8 addr)
 	u8 rdbuf;
 	int error;
 
-        error = ft5x0x_ts_readwrite(tsdata->client, 1, &addr, 1, &rdbuf);	
-	if (error)
-		dev_err(&tsdata->client->dev, "Unabled to fetch data, error: %d\n", error);
+	error = ft5x0x_ts_readwrite(tsdata->client, 1, &addr, 1, &rdbuf);
+
+	if (error) {
+		dev_err(&tsdata->client->dev, "Unable to fetch data, error: %d\n", error);
 		return error;
+	}
 
-	return rdbuf; 
+	return rdbuf;
 }
 
 static unsigned char ft5x0x_read_fw_ver(struct ft5x0x_ts_data *tsdata)
@@ -123,17 +129,20 @@ static void ft5x0x_ts_work(struct work_struct *work)
 
 	memset(rdbuf, 0, sizeof(rdbuf));
 	error = ft5x0x_ts_readwrite(tsdata->client, sizeof(cmd), &cmd, sizeof(rdbuf), rdbuf);
+
 	if (error) {
 		dev_err(dev, "Unabled to fetch data, error: %d\n", error);
 		return;
 	}
 
 	for (i = 0; i < 5; i++) {
-		u8 *buf = &rdbuf[i*6 + 3];
+		u8 *buf = &rdbuf[i * 6 + 3];
 		type = buf[0] >> 6 & 0x3;
+
 		if (type == 0x3) { //reserved touch slot does not need to be handled
 			continue;
 		}
+
 		x = ((buf[0] << 8) | buf[1]) & 0x0fff;
 		y = ((buf[2] << 8) | buf[3]) & 0x0fff;
 		id = (buf[2] >> 4) & 0x0f;
@@ -141,93 +150,48 @@ static void ft5x0x_ts_work(struct work_struct *work)
 		input_mt_slot(tsdata->input, id);
 		input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, pressed);
 
-		if (!pressed)
-			continue; //only report slot status; no need to update coordinates
+		if (!pressed) {
+			continue;        //only report slot status; no need to update coordinates
+		}
+
 		input_report_abs(tsdata->input, ABS_MT_POSITION_X, x);
 		input_report_abs(tsdata->input, ABS_MT_POSITION_Y, y);
-		dev_dbg(dev, "id: %d, x: %d, y: %d\n", i + 1, x, y);
 	}
+
 	input_mt_report_pointer_emulation(tsdata->input, true);
 	input_sync(tsdata->input);
 }
 
 static int ft5x0x_ts_reset(struct i2c_client *client, struct ft5x0x_ts_data *tsdata)
 {
-        int error;
+	int error;
 
-        if (gpio_is_valid(tsdata->wake_gpio)) {
+	if (gpio_is_valid(tsdata->wake_gpio)) {
 		/* reset is active low */
-                error = devm_gpio_request_one(&client->dev, tsdata->wake_gpio, GPIOF_OUT_INIT_LOW, "ft5x0x reset");
-                if (error) {
-                        dev_err(&client->dev, "Failed to request GPIO %d as reset pin, error %d\n", tsdata->wake_gpio, error);
-                        return error;
-                }
-                mdelay(20);
-                gpio_set_value(tsdata->wake_gpio, 1);
-        }
-
-        if (gpio_is_valid(tsdata->reset_gpio)) {
-		/* reset is active low */
-                error = devm_gpio_request_one(&client->dev,tsdata->reset_gpio, GPIOF_OUT_INIT_LOW, "ft5x0x reset");
-                if (error) {
-                        dev_err(&client->dev, "Failed to request GPIO %d as reset pin, error %d\n", tsdata->reset_gpio, error);
-                        return error;
-                }
-                mdelay(20);
-                gpio_set_value(tsdata->reset_gpio, 1);
-        }
-        return 0;
-}
-
-static int ft5x0x_i2c_ts_probe_dt(struct device *dev, struct ft5x0x_ts_data *tsdata)
-{
-    struct device_node *np = dev->of_node;
+		error = devm_gpio_request_one(&client->dev, tsdata->wake_gpio, GPIOF_OUT_INIT_LOW, "ft5x0x wake");
 
-    if (np == NULL){
-        dev_err(dev, "Null Pointer Error!!\n");
+		if (error) {
+			dev_err(&client->dev, "Failed to request GPIO %d as wake pin, error %d\n", tsdata->wake_gpio, error);
+			return error;
+		}
 
-        return ;      
-    }
+		mdelay(20);
+		gpio_set_value(tsdata->wake_gpio, 1);
+	}
 
-    tsdata->irq_gpio = -EINVAL;
-    tsdata->reset_gpio = -EINVAL; 
-    tsdata->wake_gpio = of_get_named_gpio(np, "wake-gpios", 0);
-    return 0;
+	return 0;
 }
 
-#ifdef CONFIG_OF
-static const struct ft5x0x_platform_data *ft5x0x_parse_dt(struct device *dev)
+static int ft5x0x_i2c_ts_probe_dt(struct device *dev, struct ft5x0x_ts_data *tsdata)
 {
 	struct device_node *np = dev->of_node;
-	struct ft5x0x_platform_data *pdata;
 
-	if (!np)
-		return NULL;
-
-	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata) {
-		dev_err(dev, "failed to allocate platform data\n");
-		return NULL;
-	}
+	tsdata->irq_gpio = -EINVAL;
+	tsdata->reset_gpio = -EINVAL;
+	tsdata->wake_gpio = of_get_named_gpio(np, "wake-gpios", 0);
 
-	if (of_property_read_u32(np, "wake-gpios", &pdata->wake_gpio)) {
-		dev_err(dev, "failed to get property wake_gpio property\n");
-		return NULL;
-	}; 
-
-	if (of_property_read_u32(np, "reset-gpios", &pdata->irq_gpio)) {
-		dev_err(dev, "failed to get property irq_gpio property\n");
-		return NULL;
-	}; 
-	
-	return pdata;
-}
-#else
-static inline const struct ft5x0x_platform_data *ft5x0x_parse_dt(struct device *dev)
-{
-	return NULL;
+	return 0;
 }
-#endif
 
 static int ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
@@ -235,49 +199,52 @@ static int ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	struct ft5x0x_ts_data *tsdata;
 	struct input_dev *input;
 	int error;
-	
 
 	pdata = dev_get_platdata(&client->dev);
 
 	tsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);
 
-    if (!tsdata) {
-        dev_err(&client->dev, "Failed to allocate driver data.\n");
-        return -ENOMEM;
-    }
+	if (!tsdata) {
+		dev_err(&client->dev, "Failed to allocate driver data.\n");
+		return -ENOMEM;
+	}
 
 	if (!pdata) {
-        error =ft5x0x_i2c_ts_probe_dt(&client->dev, tsdata);
-        if (error) {
-            dev_err(&client->dev, "DT probe failed and no platform data present\n");
-            return error;
-        }
+		error = ft5x0x_i2c_ts_probe_dt(&client->dev, tsdata);
+		if (error) {
+			dev_err(&client->dev, "DT probe failed and no platform data present\n");
+			return error;
+		}
+	} else {
+		tsdata->irq_gpio = pdata->irq_gpio;
+		tsdata->wake_gpio = pdata->wake_gpio;
 	}
 
 	error = ft5x0x_ts_reset(client, tsdata);
-    if (error)
-        return error;
-
-        if (gpio_is_valid(tsdata->irq_gpio)) {
-            error = devm_gpio_request_one(&client->dev, tsdata->irq_gpio, GPIOF_IN, "ft5x0x irq");
-            if (error) {
-                dev_err(&client->dev, "Failed to request GPIO %d, error %d\n", tsdata->irq_gpio, error);
-                return error;
-            }
-	        else {
-	            dev_dbg(&client->dev, "Victory is mine!\n");
-	        }
-        }
-	    else {
-	    	dev_err(&client->dev, "irq_gpio is invalid\n");
-	    }
-
-	input = input_allocate_device();
+
+	if (error) {
+		return error;
+	}
+
+	if (gpio_is_valid(tsdata->irq_gpio)) {
+		error = devm_gpio_request_one(&client->dev, tsdata->irq_gpio, GPIOF_IN, "ft5x0x irq");
+
+		if (error) {
+			dev_err(&client->dev, "Failed to request GPIO %d, error %d\n", tsdata->irq_gpio, error);
+			return error;
+	}
+	} else {
+		dev_dbg(&client->dev, "irq_gpio: %d\n", tsdata->irq_gpio);
+		dev_err(&client->dev, "irq_gpio is invalid\n");
+	}
+
+	input = devm_input_allocate_device(&client->dev);
+
 	if (!tsdata || !input) {
 		dev_err(&client->dev, "Failed to allocate driver data.\n");
-		error = -ENOMEM;
-		goto err_free_mem;
+		return -ENOMEM;
 	}
+
 	INIT_DELAYED_WORK(&tsdata->work, ft5x0x_ts_work);
 
 	tsdata->client = client;
@@ -303,72 +270,57 @@ static int ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	input_set_drvdata(input, tsdata);
 	i2c_set_clientdata(client, tsdata);
 
-	error = request_irq(client->irq, ft5x0x_ts_isr, IRQF_TRIGGER_FALLING, dev_name(&client->dev), tsdata);
+	error = devm_request_irq(&client->dev, client->irq, ft5x0x_ts_isr, IRQF_TRIGGER_FALLING, dev_name(&client->dev),
+				 tsdata);
 
-	//if (error < 0) {
 	if (error != 0) {
 		dev_err(&client->dev, "FT5x0x: Unable to request touchscreen IRQ.\n");
-		goto err_free_mem;
+		return error;
 	}
 
 	error = input_register_device(input);
+
 	if (error) {
 		dev_err(&client->dev, "ft5x0x_ts_probe: failed to register input device: %s\n", dev_name(&client->dev));
-		goto err_free_irq;
+		return error;
 	}
+
 	device_init_wakeup(&client->dev, 1);
 
 	dev_dbg(&client->dev, "FT5x0x initialized\n");
 	return 0;
-
-err_free_irq:
-	free_irq(client->irq, tsdata);
-err_free_mem:
-	input_free_device(input);
-	kfree(tsdata);
-	return error;
 }
 
 static int ft5x0x_ts_remove(struct i2c_client *client)
 {
-	const struct ft5x0x_platform_data *pdata = dev_get_platdata(&client->dev);
 	struct ft5x0x_ts_data *tsdata = i2c_get_clientdata(client);
 
-	free_irq(client->irq, tsdata);
 	input_unregister_device(tsdata->input);
 
-        if (gpio_is_valid(pdata->irq_gpio))
-                gpio_free(pdata->irq_gpio);
-        if (gpio_is_valid(pdata->wake_gpio))
-                gpio_free(pdata->wake_gpio);
-
-	kfree(tsdata);
-	dev_dbg(&client->dev, "FT5x0x removed");
-
 	return 0;
 }
 
 #ifdef CONFIG_PM_SLEEP
 static int ft5x0x_ts_suspend(struct device *dev)
 {
-        struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_client *client = to_i2c_client(dev);
 
-	//ft5x0x_register_write(dev, FT5X0X_REG_POWER_MODE, 0x03);
-        if (device_may_wakeup(dev))
-                enable_irq_wake(client->irq);
+	if (device_may_wakeup(dev)) {
+		enable_irq_wake(client->irq);
+	}
 
-        return 0;
+	return 0;
 }
 
 static int ft5x0x_ts_resume(struct device *dev)
 {
-        struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_client *client = to_i2c_client(dev);
 
-	//ft5x0x_register_write(dev, FT5X0X_REG_POWER_MODE, 0x00);
-        if (device_may_wakeup(dev))
-                disable_irq_wake(client->irq);
+	if (device_may_wakeup(dev)) {
+		disable_irq_wake(client->irq);
+	}
 
-        return 0;
+	return 0;
 }
 #endif
 
@@ -392,25 +344,14 @@ static struct i2c_driver ft5x0x_ts_driver = {
 	.driver	= {
 		.name	= FT5X0X_NAME,
 		.owner	= THIS_MODULE,
-        .of_match_table = ft5x0x_dt_match,
+		.of_match_table = ft5x0x_dt_match,
 	},
 	.probe		= ft5x0x_ts_probe,
 	.remove		= ft5x0x_ts_remove,
 	.id_table	= ft5x0x_ts_id,
 };
 
-static int __init ft5x0x_init(void)
-{
-        return i2c_add_driver(&ft5x0x_ts_driver);
-}
-
-static void __exit ft5x0x_exit(void)
-{
-        i2c_del_driver(&ft5x0x_ts_driver);
-}
-
-module_init(ft5x0x_init);
-module_exit(ft5x0x_exit);
+module_i2c_driver(ft5x0x_ts_driver);
 
 MODULE_AUTHOR("Ash Charles <ash@gumstix.com>");
 MODULE_AUTHOR("Adam Lee <adam@gumstix.com>");
-- 
1.9.1

