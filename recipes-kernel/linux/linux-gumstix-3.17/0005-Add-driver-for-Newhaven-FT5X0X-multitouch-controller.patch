From 34453ce67320ef45146a126d9924104ad0351c30 Mon Sep 17 00:00:00 2001
From: Adam YH Lee <adam.yh.lee@gmail.com>
Date: Mon, 8 Dec 2014 13:11:02 -0800
Subject: [PATCH 1/2] Add driver for Newhaven FT5X0X multitouch controller

Tested with Device Tree enabled Linux Kernel 3.17.4
on Gumstix Arbor43C using an Overo AirStorm. Backward
compatibility with the Kernel 3.5 has not been done.
---
 drivers/input/touchscreen/Kconfig     |   9 +
 drivers/input/touchscreen/Makefile    |   1 +
 drivers/input/touchscreen/ft5x06_ts.c | 418 ++++++++++++++++++++++++++++++++++
 include/linux/input/ft5x06_ts.h       |  25 ++
 4 files changed, 453 insertions(+)
 create mode 100644 drivers/input/touchscreen/ft5x06_ts.c
 create mode 100644 include/linux/input/ft5x06_ts.h

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 6bb9a7d..ea01bf4 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -239,6 +239,15 @@ config TOUCHSCREEN_DYNAPRO
 	  To compile this driver as a module, choose M here: the
 	  module will be called dynapro.
 
+config TOUCHSCREEN_NEWHAVEN_FT5X0X
+	tristate "Newhaven FT5x0x I2C Touchscreen support"
+	depends on I2C
+	help
+	   Say Y here if you have a Newhaven Capacitive touchscreen using 
+	    a FT5x0x touch controllers. Note: not compatible with EDT
+	    "Polytouch" controllers.
+
+
 config TOUCHSCREEN_HAMPSHIRE
 	tristate "Hampshire serial touchscreen"
 	select SERIO
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 4be94fc..1792fd9 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -78,3 +78,4 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
+obj-$(CONFIG_TOUCHSCREEN_NEWHAVEN_FT5X0X)	+= ft5x06_ts.o
diff --git a/drivers/input/touchscreen/ft5x06_ts.c b/drivers/input/touchscreen/ft5x06_ts.c
new file mode 100644
index 0000000..e863ab7
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x06_ts.c
@@ -0,0 +1,418 @@
+/*
+ * Copyright (C) 2010 Focal Tech Ltd.
+ * Copyright (C) 2013, Ash Charles <ash@gumstix.com>
+ * Copyright (C) 2014, Adam Lee <adam@gumstix.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* 
+ * This is a driver for the FocalTech FT5x0x family of touch controllers
+ * use in Newhaven capacitive touchscreens.  Note: this does not support with
+ * EDT "Polytouch" controllers.
+ */
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/input/mt.h>
+#include <linux/input/ft5x06_ts.h>
+
+struct ft5x0x_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct delayed_work work;
+
+    int reset_gpio;
+    int irq_gpio;
+    int wake_gpio;
+};
+
+static int ft5x0x_ts_readwrite(struct i2c_client *client, u16 wr_len, u8 *wr_buf, u16 rd_len, u8 *rd_buf)
+{
+	struct i2c_msg wrmsg[2];
+	int i = 0;
+	int ret;
+	if (wr_len) {
+		wrmsg[i].addr = client->addr;
+		wrmsg[i].flags = 0;
+		wrmsg[i].len = wr_len;
+		wrmsg[i].buf = wr_buf;
+		i++;
+	}
+
+	if (rd_len) {
+		wrmsg[i].addr = client->addr;
+		wrmsg[i].flags = I2C_M_RD;
+		wrmsg[i].len = rd_len;
+		wrmsg[i].buf = rd_buf;
+		i++;
+	}
+	
+	ret = i2c_transfer(client->adapter, wrmsg, i);
+	if (ret < 0)
+		return ret;
+	if (ret != i)
+		return -EIO;
+
+	return 0;
+}
+
+static int ft5x0x_register_write(struct ft5x0x_ts_data *tsdata, u8 addr, u8 value)
+{
+	u8 wrbuf[2];
+        wrbuf[0] = addr;
+        wrbuf[1] = value;
+
+        return ft5x0x_ts_readwrite(tsdata->client, 2, wrbuf, 0, NULL);
+}
+
+static int ft5x0x_register_read(struct ft5x0x_ts_data *tsdata, u8 addr)
+{
+	u8 rdbuf;
+	int error;
+
+        error = ft5x0x_ts_readwrite(tsdata->client, 1, &addr, 1, &rdbuf);	
+	if (error)
+		dev_err(&tsdata->client->dev, "Unabled to fetch data, error: %d\n", error);
+		return error;
+
+	return rdbuf; 
+}
+
+static unsigned char ft5x0x_read_fw_ver(struct ft5x0x_ts_data *tsdata)
+{
+	return ft5x0x_register_read(tsdata, FT5X0X_REG_FIRMID);
+}
+
+static irqreturn_t ft5x0x_ts_isr(int irq, void *dev_id)
+{
+	struct ft5x0x_ts_data *tsdata = dev_id;
+	schedule_delayed_work(&tsdata->work, 0);
+	return IRQ_HANDLED;
+}
+static void ft5x0x_ts_work(struct work_struct *work)
+{
+	struct delayed_work *dw = container_of(work, struct delayed_work, work);
+	struct ft5x0x_ts_data *tsdata = container_of(dw, struct ft5x0x_ts_data, work);
+	struct device *dev = &tsdata->client->dev;
+	u8 cmd = 0x00;
+	u8 rdbuf[32];
+	int i, x, y, id;
+	bool pressed;
+	int error, type;
+
+	memset(rdbuf, 0, sizeof(rdbuf));
+	error = ft5x0x_ts_readwrite(tsdata->client, sizeof(cmd), &cmd, sizeof(rdbuf), rdbuf);
+	if (error) {
+		dev_err(dev, "Unabled to fetch data, error: %d\n", error);
+		return;
+	}
+
+	for (i = 0; i < 5; i++) {
+		u8 *buf = &rdbuf[i*6 + 3];
+		type = buf[0] >> 6 & 0x3;
+		if (type == 0x3) { //reserved touch slot does not need to be handled
+			continue;
+		}
+		x = ((buf[0] << 8) | buf[1]) & 0x0fff;
+		y = ((buf[2] << 8) | buf[3]) & 0x0fff;
+		id = (buf[2] >> 4) & 0x0f;
+		pressed = (type != 0x01); // as long as finger is not up, we are tracking
+		input_mt_slot(tsdata->input, id);
+		input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, pressed);
+
+		if (!pressed)
+			continue; //only report slot status; no need to update coordinates
+		input_report_abs(tsdata->input, ABS_MT_POSITION_X, x);
+		input_report_abs(tsdata->input, ABS_MT_POSITION_Y, y);
+		dev_dbg(dev, "id: %d, x: %d, y: %d\n", i + 1, x, y);
+	}
+	input_mt_report_pointer_emulation(tsdata->input, true);
+	input_sync(tsdata->input);
+}
+
+static int ft5x0x_ts_reset(struct i2c_client *client, struct ft5x0x_ts_data *tsdata)
+{
+        int error;
+
+        if (gpio_is_valid(tsdata->wake_gpio)) {
+		/* reset is active low */
+                error = devm_gpio_request_one(&client->dev, tsdata->wake_gpio, GPIOF_OUT_INIT_LOW, "ft5x0x reset");
+                if (error) {
+                        dev_err(&client->dev, "Failed to request GPIO %d as reset pin, error %d\n", tsdata->wake_gpio, error);
+                        return error;
+                }
+                mdelay(20);
+                gpio_set_value(tsdata->wake_gpio, 1);
+        }
+
+        if (gpio_is_valid(tsdata->reset_gpio)) {
+		/* reset is active low */
+                error = devm_gpio_request_one(&client->dev,tsdata->reset_gpio, GPIOF_OUT_INIT_LOW, "ft5x0x reset");
+                if (error) {
+                        dev_err(&client->dev, "Failed to request GPIO %d as reset pin, error %d\n", tsdata->reset_gpio, error);
+                        return error;
+                }
+                mdelay(20);
+                gpio_set_value(tsdata->reset_gpio, 1);
+        }
+        return 0;
+}
+
+static int ft5x0x_i2c_ts_probe_dt(struct device *dev, struct ft5x0x_ts_data *tsdata)
+{
+    struct device_node *np = dev->of_node;
+
+    if (np == NULL){
+        dev_err(dev, "Null Pointer Error!!\n");
+
+        return ;      
+    }
+
+    tsdata->irq_gpio = -EINVAL;
+    tsdata->reset_gpio = -EINVAL; 
+    tsdata->wake_gpio = of_get_named_gpio(np, "wake-gpios", 0);
+    return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct ft5x0x_platform_data *ft5x0x_parse_dt(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct ft5x0x_platform_data *pdata;
+
+	if (!np)
+		return NULL;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "failed to allocate platform data\n");
+		return NULL;
+	}
+
+	if (of_property_read_u32(np, "wake-gpios", &pdata->wake_gpio)) {
+		dev_err(dev, "failed to get property wake_gpio property\n");
+		return NULL;
+	}; 
+
+	if (of_property_read_u32(np, "reset-gpios", &pdata->irq_gpio)) {
+		dev_err(dev, "failed to get property irq_gpio property\n");
+		return NULL;
+	}; 
+	
+	return pdata;
+}
+#else
+static inline const struct ft5x0x_platform_data *ft5x0x_parse_dt(struct device *dev)
+{
+	return NULL;
+}
+#endif
+
+static int ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	const struct ft5x0x_platform_data *pdata;
+	struct ft5x0x_ts_data *tsdata;
+	struct input_dev *input;
+	int error;
+	
+
+	pdata = dev_get_platdata(&client->dev);
+
+	tsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);
+
+    if (!tsdata) {
+        dev_err(&client->dev, "Failed to allocate driver data.\n");
+        return -ENOMEM;
+    }
+
+	if (!pdata) {
+        error =ft5x0x_i2c_ts_probe_dt(&client->dev, tsdata);
+        if (error) {
+            dev_err(&client->dev, "DT probe failed and no platform data present\n");
+            return error;
+        }
+	}
+
+	error = ft5x0x_ts_reset(client, tsdata);
+    if (error)
+        return error;
+
+        if (gpio_is_valid(tsdata->irq_gpio)) {
+            error = devm_gpio_request_one(&client->dev, tsdata->irq_gpio, GPIOF_IN, "ft5x0x irq");
+            if (error) {
+                dev_err(&client->dev, "Failed to request GPIO %d, error %d\n", tsdata->irq_gpio, error);
+                return error;
+            }
+	        else {
+	            dev_dbg(&client->dev, "Victory is mine!\n");
+	        }
+        }
+	    else {
+	    	dev_err(&client->dev, "irq_gpio is invalid\n");
+	    }
+
+	input = input_allocate_device();
+	if (!tsdata || !input) {
+		dev_err(&client->dev, "Failed to allocate driver data.\n");
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+	INIT_DELAYED_WORK(&tsdata->work, ft5x0x_ts_work);
+
+	tsdata->client = client;
+	tsdata->input = input;
+
+	dev_dbg(&client->dev, "FT5x0x Firmware version: 0x%x\n", ft5x0x_read_fw_ver(tsdata));
+
+	input->name = FT5X0X_NAME;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+
+	__set_bit(EV_SYN, input->evbit);
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+	input_set_abs_params(input, ABS_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, SCREEN_MAX_Y, 0, 0);
+
+	input_mt_init_slots(input, 5, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, SCREEN_MAX_Y, 0, 0);
+
+	input_set_drvdata(input, tsdata);
+	i2c_set_clientdata(client, tsdata);
+
+	error = request_irq(client->irq, ft5x0x_ts_isr, IRQF_TRIGGER_FALLING, dev_name(&client->dev), tsdata);
+
+	//if (error < 0) {
+	if (error != 0) {
+		dev_err(&client->dev, "FT5x0x: Unable to request touchscreen IRQ.\n");
+		goto err_free_mem;
+	}
+
+	error = input_register_device(input);
+	if (error) {
+		dev_err(&client->dev, "ft5x0x_ts_probe: failed to register input device: %s\n", dev_name(&client->dev));
+		goto err_free_irq;
+	}
+	device_init_wakeup(&client->dev, 1);
+
+	dev_dbg(&client->dev, "FT5x0x initialized\n");
+	return 0;
+
+err_free_irq:
+	free_irq(client->irq, tsdata);
+err_free_mem:
+	input_free_device(input);
+	kfree(tsdata);
+	return error;
+}
+
+static int ft5x0x_ts_remove(struct i2c_client *client)
+{
+	const struct ft5x0x_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct ft5x0x_ts_data *tsdata = i2c_get_clientdata(client);
+
+	free_irq(client->irq, tsdata);
+	input_unregister_device(tsdata->input);
+
+        if (gpio_is_valid(pdata->irq_gpio))
+                gpio_free(pdata->irq_gpio);
+        if (gpio_is_valid(pdata->wake_gpio))
+                gpio_free(pdata->wake_gpio);
+
+	kfree(tsdata);
+	dev_dbg(&client->dev, "FT5x0x removed");
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int ft5x0x_ts_suspend(struct device *dev)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+
+	//ft5x0x_register_write(dev, FT5X0X_REG_POWER_MODE, 0x03);
+        if (device_may_wakeup(dev))
+                enable_irq_wake(client->irq);
+
+        return 0;
+}
+
+static int ft5x0x_ts_resume(struct device *dev)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+
+	//ft5x0x_register_write(dev, FT5X0X_REG_POWER_MODE, 0x00);
+        if (device_may_wakeup(dev))
+                disable_irq_wake(client->irq);
+
+        return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(ft5x0x_ts_pm_ops, ft5x0x_ts_suspend, ft5x0x_ts_resume);
+
+static const struct i2c_device_id ft5x0x_ts_id[] = {
+	{ FT5X0X_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ft5x0x_ts_id);
+
+#ifdef CONFIG_OF
+static struct of_device_id ft5x0x_dt_match[] = {
+	{ .compatible = "focaltech,ft5x0x" },
+	{},
+};
+#endif
+
+static struct i2c_driver ft5x0x_ts_driver = {
+	.driver	= {
+		.name	= FT5X0X_NAME,
+		.owner	= THIS_MODULE,
+        .of_match_table = ft5x0x_dt_match,
+	},
+	.probe		= ft5x0x_ts_probe,
+	.remove		= ft5x0x_ts_remove,
+	.id_table	= ft5x0x_ts_id,
+};
+
+static int __init ft5x0x_init(void)
+{
+        return i2c_add_driver(&ft5x0x_ts_driver);
+}
+
+static void __exit ft5x0x_exit(void)
+{
+        i2c_del_driver(&ft5x0x_ts_driver);
+}
+
+module_init(ft5x0x_init);
+module_exit(ft5x0x_exit);
+
+MODULE_AUTHOR("Ash Charles <ash@gumstix.com>");
+MODULE_AUTHOR("Adam Lee <adam@gumstix.com>");
+MODULE_DESCRIPTION("FocalTech FT5x0x Touchscreen driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/input/ft5x06_ts.h b/include/linux/input/ft5x06_ts.h
new file mode 100644
index 0000000..bb1c190
--- /dev/null
+++ b/include/linux/input/ft5x06_ts.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2013 Ash Charles <ash@gumstix.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef _FT5X0X_TS_H__
+#define _FT5X0X_TS_H__
+
+#define SCREEN_MAX_X    470
+#define SCREEN_MAX_Y    275
+#define PRESS_MAX       255
+
+#define FT5X0X_NAME	"ft5x0x_ts"
+#define FT5X0X_REG_POWER_MODE	0xa5
+#define FT5X0X_REG_FIRMID	0xa6
+
+
+struct ft5x0x_platform_data {
+	unsigned int irq_gpio;
+	unsigned int wake_gpio;
+};
+
+#endif /* _FT5X0X_TS_H__ */
-- 
1.9.1

